<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Framework 4 - Final Logic Test</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }
        #on-screen-console {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #00FF00;
            font-family: monospace;
            padding: 8px;
            border-radius: 5px;
            z-index: 300;
            font-size: 14px;
            min-width: 150px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="on-screen-console"></div>

    <script>
        'use strict';

        // --- SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const consoleDiv = document.getElementById('on-screen-console');
        let lastTime = 0;

        // --- GLOBALS FOR UPDATE FUNCTIONS ---
        let isPlayerInGarage = false;
        let isGameBlocked = false;
        let playerStats = { kills: 0 }; // Dummy object for compatibility
        let keys = { w: false, a: false, s: false, d: false }; // Dummy input state
        let touchState = { moveStick: { x: 0, y: 0 }}; // Dummy input state

        // --- STATIC GAME STATE (FOR DRAWING ONLY) ---
        const world = { width: 4000, height: 4000, gridSize: 40 };
        const TILE_TYPE = { GRASS: 1, WATER: 4 };
        let camera = { x: 1800, y: 1800, width: 0, height: 0, zoom: 1.0 };
        let player = { x: 2000, y: 2000, width: 35, height: 35, bodyAngle: 0.5, turretAngle: -1.0, isHit: false, boost: {isBoosting: false} };
        
        // Dummy data for drawing functions
        const cashBayUpgrades = [{ cost: 25, passive: 0.10, active: 0.20 }];
        const medBayUpgrades = [{ cost: 0, heal: 0, maxHp: 0 }, { cost: 25, heal: 0.25, maxHp: 5 }];

        let worldState = {
            worldObjects: [
                { type: 'tree', x: 2100, y: 2050, size: 40, leafyDetails: [{x:5,y:5,r:5}] },
                { type: 'block', x: 2150, y: 1950, width: 40, height: 40, hits: 0, cracks: null, speckles: [{x:10,y:10,size:2}] }
            ],
            enemies: [
                { type: 'normal', x: 1900, y: 1900, width: 35, height: 35, angle: 0, isHit: false },
                { type: 'elite', x: 2100, y: 1900, width: 40, height: 40, angle: 0, isHit: true }
            ],
            pickups: [
                { type: 'money', value: 50, x: 2050, y: 2050, radius: 10 },
                { type: 'heart', x: 1950, y: 2050, radius: 15 }
            ],
            base: {
                x: 1880, y: 1880, size: 14 * 40,
                cashBay: { tier: 1, x: 1880 + (9 * 40), y: 1880 + (7 * 40), width: 80, height: 80 },
                medBay: { tier: 1, x: 1880 + (3 * 40), y: 1880 + (7 * 40), width: 80, height: 80 },
                pads: []
            },
            bullets: [{x: 1980, y: 1980, radius: 5, owner: 'player'}],
            activeBursts: [],
            particles: [{type: 'money', x: 2000, y: 1950, life: 50, color: '#fbbf24'}],
            decorations: [{x: 2200, y: 2200, angle: 1, length: 15, dark: false}],
            baseDecorations: [{x: 1900, y: 1900, angle: 2, length: 10}],
            pings: [],
            tileMap: Array.from({ length: world.height / world.gridSize }, () => Array(world.width / world.gridSize).fill(TILE_TYPE.GRASS))
        };
        // Add a small patch of water for testing
        worldState.tileMap[50][52] = TILE_TYPE.WATER;
        worldState.tileMap[51][52] = TILE_TYPE.WATER;


        // --- DRAWING FUNCTIONS (Copied from main game) ---
        function formatMoney(amount) {
            if (amount >= 1000) return (amount / 1000).toFixed(1) + 'k';
            return amount.toFixed(2);
        }

        function drawStroked(drawFunc) { ctx.lineWidth = 3; ctx.strokeStyle = 'black'; ctx.stroke(); drawFunc(); }
        function drawTank(x, y, width, height, bodyAngle, turretAngle, bodyColor = "#A0AEC0", turretColor = "#718096", isHit = false, isBoosting = false) { if (isHit) bodyColor = '#ef4444'; ctx.save(); ctx.translate(x + width / 2, y + height / 2); ctx.save(); ctx.rotate(bodyAngle); drawStroked(() => { ctx.fillStyle = "#4A5568"; ctx.fillRect(-width / 2, -height / 2, width, height); ctx.fillStyle = bodyColor; ctx.fillRect(-width / 2 * 0.8, -height / 2 * 0.8, width * 0.8, height * 0.8); }); ctx.restore(); ctx.rotate(turretAngle); drawStroked(() => { ctx.fillStyle = turretColor; ctx.fillRect(-width/4, -height/8, width/2, height/4); ctx.fillRect(0, -width/16, width/2, width/8); }); ctx.restore(); }
        function drawTree(x, y, size, leafyDetails) { const trunkColor = '#6b462a', leavesColor1 = '#166534', trunkSize = size / 5; ctx.fillStyle = trunkColor; ctx.fillRect(x + size / 2 - trunkSize / 2, y + size / 2, trunkSize, size / 2); drawStroked(() => { ctx.fillStyle = leavesColor1; ctx.beginPath(); ctx.arc(x + size / 2, y + size / 3, size / 2.2, 0, Math.PI * 2); ctx.fill(); }); }
        function drawDeadBush(x, y, size) { ctx.save(); ctx.translate(x + size / 2, y + size / 2); ctx.strokeStyle = 'black'; ctx.lineWidth = 4; ctx.lineCap = 'round'; for (let i = 0; i < 3; i++) { ctx.rotate(Math.PI / 3); ctx.beginPath(); ctx.moveTo(0, -size / 2.5); ctx.lineTo(0, size / 2.5); ctx.stroke(); } ctx.restore(); }
        function drawCrackedBlock(x, y, width, height, color, crackCoords, speckles) { ctx.fillStyle = 'black'; ctx.fillRect(x, y, width, height); ctx.fillStyle = color; ctx.fillRect(x + 2, y + 2, width - 4, height - 4); }
        function drawCashBay(x, y, width, height) { ctx.fillStyle = '#166534'; ctx.fillRect(x, y, width, height); ctx.fillStyle = '#22c55e'; ctx.font = 'bold 60px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', x + width / 2, y + height / 2); }
        function drawCashBag(x, y, size) { ctx.fillStyle = '#166534'; ctx.beginPath(); ctx.roundRect(x, y, size, size, [8]); ctx.fill(); ctx.strokeStyle = 'black'; ctx.lineWidth = 3; ctx.stroke(); ctx.fillStyle = '#fBBF24'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', x + size / 2, y + size / 2); }
        function drawMedBayPad(x, y, width, height) { ctx.fillStyle = '#166534'; ctx.fillRect(x, y, width, height); ctx.fillStyle = '#22c55e'; ctx.font = 'bold 60px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('+', x + width / 2, y + height / 2); }
        function drawGarage(x, y, width, height) { ctx.fillStyle = '#475569'; ctx.fillRect(x, y, width, height); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 4; ctx.strokeRect(x, y, width, height); ctx.fillStyle = '#334155'; ctx.fillRect(x + 5, y + 5, width - 10, height - 10); }
        function drawBlueprint(x, y, size, id) { ctx.font = `${size * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ“„', x + size/2, y + size/2); }
        function drawBlueHeart(x, y, radius) { drawStroked(() => { ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.moveTo(x, y - radius / 2); ctx.bezierCurveTo(x, y - radius, x - radius, y - radius, x - radius, y); ctx.bezierCurveTo(x - radius, y + radius / 2, x, y + radius, x, y + radius); ctx.bezierCurveTo(x, y + radius, x + radius, y + radius / 2, x + radius, y); ctx.bezierCurveTo(x + radius, y - radius, x, y - radius, x, y - radius / 2); ctx.fill(); }); }
        function drawPingLine(startX, startY, endX, endY, color, text) { ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke(); }
        function drawWorld() { const colors = { grass: '#48D43B', water: '#0000FF', block: '#E2E8F0', base: '#374151' }; const startX = Math.floor(camera.x / world.gridSize), endX = Math.ceil((camera.x + camera.width) / world.gridSize), startY = Math.floor(camera.y / world.gridSize), endY = Math.ceil((camera.y + camera.height) / world.gridSize); ctx.fillStyle = colors.grass; ctx.fillRect(camera.x, camera.y, camera.width, camera.height); for (let y = startY; y < endY; y++) { for (let x = startX; x < endX; x++) { if (worldState.tileMap[y] && worldState.tileMap[y][x] === TILE_TYPE.WATER) { ctx.fillStyle = colors.water; ctx.fillRect(x * world.gridSize, y * world.gridSize, world.gridSize + 1, world.gridSize + 1); } } } for(const d of worldState.decorations) { ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle); ctx.beginPath(); ctx.moveTo(0, -d.length/2); ctx.lineTo(0, d.length/2); ctx.stroke(); ctx.restore(); } if (worldState.base.x) { ctx.fillStyle = colors.base; ctx.fillRect(worldState.base.x, worldState.base.y, worldState.base.size, worldState.base.size); for(const d of worldState.baseDecorations) { ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2; ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle); ctx.beginPath(); ctx.moveTo(0, -d.length/2); ctx.lineTo(0, d.length/2); ctx.stroke(); ctx.restore(); } } for (const obj of worldState.worldObjects) { if (obj.type === 'block') { drawCrackedBlock(obj.x, obj.y, obj.width, obj.height, colors.block); } else if (obj.type === 'tree') { drawTree(obj.x, obj.y, obj.size, obj.leafyDetails); } } if(worldState.base.cashBay) { drawCashBay(worldState.base.cashBay.x, worldState.base.cashBay.y, worldState.base.cashBay.width, worldState.base.cashBay.height); } if(worldState.base.medBay) { drawMedBayPad(worldState.base.medBay.x, worldState.base.medBay.y, worldState.base.medBay.width, worldState.base.medBay.height); } }
        function drawDynamicElements() { for (const p of worldState.pickups) { if (p.type === 'money') { ctx.fillStyle = '#22c55e'; ctx.fillRect(p.x - 12, p.y - 8, 24, 16); ctx.fillStyle='white'; ctx.font='bold 12px "Times New Roman", serif'; ctx.textAlign = 'center'; ctx.fillText(`$${p.value}`, p.x, p.y+4); } else if (p.type === 'heart') { drawStroked(() => { ctx.fillStyle = '#e11d48'; ctx.beginPath(); ctx.moveTo(p.x, p.y - p.radius / 2); ctx.bezierCurveTo(p.x, p.y - p.radius, p.x - p.radius, p.y - p.radius, p.x - p.radius, p.y); ctx.bezierCurveTo(p.x - p.radius, p.y + p.radius / 2, p.x, p.y + p.radius, p.x, p.y + p.radius); ctx.bezierCurveTo(p.x, p.y + p.radius, p.x + p.radius, p.y + p.radius / 2, p.x + p.radius, p.y); ctx.bezierCurveTo(p.x + p.radius, p.y - p.radius, p.x, p.y - p.radius, p.x, p.y - p.radius / 2); ctx.fill(); }); } } for (const p of worldState.particles) { ctx.globalAlpha = p.life / 100; if (p.type === 'money') { ctx.fillStyle = p.color; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText('$', p.x, p.y); } ctx.globalAlpha = 1.0; } for (const b of worldState.bullets) { ctx.fillStyle='black';ctx.beginPath();ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);ctx.fill();ctx.fillStyle=b.owner==='player'?'#FBBF24':'#f472b6';ctx.beginPath();ctx.arc(b.x,b.y,b.radius-2,0,Math.PI*2);ctx.fill(); } for (const e of worldState.enemies) { drawTank(e.x, e.y, e.width, e.height, e.angle, e.angle, e.type === 'elite' ? '#991b1b' : '#7f1d1d', e.type === 'elite' ? '#facc15' : '#718096', e.isHit); } }
        function drawOnscreenUI() { ctx.save(); ctx.textAlign = 'center'; ctx.textShadow = '1px 1px 2px black'; if (worldState.base.cashBay) { ctx.font = 'bold 16px Arial'; ctx.fillStyle = 'white'; ctx.fillText('CASH BAY', worldState.base.cashBay.x + worldState.base.cashBay.width / 2, worldState.base.cashBay.y - 25); } ctx.restore(); }
        function drawPlayerAndPings() { if (player) { drawTank(player.x, player.y, player.width, player.height, player.bodyAngle, player.turretAngle, "#A0AEC0", "#718096", player.isHit, false); } }
        function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y); drawWorld(); drawDynamicElements(); drawOnscreenUI(); drawPlayerAndPings(); ctx.restore(); }


        // --- LOGIC FUNCTIONS & STUBS ---

        // Dummy/Stub functions to prevent crashes during test
        function playUrlSound(soundName) {}
        function playSound(soundName, ...args) {}
        function handlePlayerDeath() {}
        function dropLoot(x, y, type) {}
        function unlockAchievement(id) {}

        // Dummy spatial grid that returns all objects (worst-case performance test)
        const spatialGrid = {
            getNearby: (x, y) => [...worldState.worldObjects, ...worldState.enemies, player]
        };
        
        // Copied Logic Functions from main game
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
        function isCollidingWithObject(x, y, width, height) { for (const obj of worldState.worldObjects) { if (x < obj.x + (obj.width || obj.size) && x + width > obj.x && y < obj.y + (obj.height || obj.size) && y + height > obj.y) return true; } return false; }
        function checkCollision(x, y, width = player.width, height = player.height) { return isCollidingWithObject(x, y, width, height); }

        function updatePlayer(deltaTime) {
            if (player.isDead || isGameBlocked) return;
            let dx = 0, dy = 0, targetSpeed = 0;
            const isTryingToMove = (touchState.moveStick.x !== 0 || touchState.moveStick.y !== 0) || keys.w || keys.a || keys.s || keys.d;
            if (isTryingToMove) {
                if (keys.w) dy -= 1;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) { dx /= dist; dy /= dist; }
                player.bodyAngle = Math.atan2(dy, dx);
                targetSpeed = player.speed || 1.94;
            }
            player.currentSpeed += ((targetSpeed) - player.currentSpeed) * (player.acceleration || 0.025);
            const finalSpeed = player.currentSpeed;
            if (Math.abs(finalSpeed) > 0.01) {
                const nextX = player.x + Math.cos(player.bodyAngle) * finalSpeed;
                const nextY = player.y + Math.sin(player.bodyAngle) * finalSpeed;
                if (!checkCollision(nextX, player.y)) player.x = nextX;
                if (!checkCollision(player.x, nextY)) player.y = nextY;
            }
        }

        function updateEnemies() {
            for (const e of worldState.enemies) {
                const distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
                if (!player.isDead && distToPlayer < (e.aggroRange || 300)) {
                    e.angle = Math.atan2(player.y - e.y, player.x - e.x);
                    const nextX = e.x + Math.cos(e.angle) * (e.speed || 1.0);
                    const nextY = e.y + Math.sin(e.angle) * (e.speed || 1.0);
                    if (!isCollidingWithObject(nextX, e.y, e.width, e.height)) e.x = nextX;
                    if (!isCollidingWithObject(e.x, nextY, e.width, e.height)) e.y = nextY;
                } else {
                    if (!e.targetPos || Math.hypot(e.x - e.targetPos.x, e.y - e.targetPos.y) < 10) {
                        e.targetPos = { x: e.x + (Math.random() - 0.5) * 100, y: e.y + (Math.random() - 0.5) * 100 };
                    }
                    e.angle = Math.atan2(e.targetPos.y - e.y, e.targetPos.x - e.x);
                    e.x = clamp(e.x + Math.cos(e.angle) * 0.5, 0, world.width - e.width);
                    e.y = clamp(e.y + Math.sin(e.angle) * 0.5, 0, world.height - e.height);
                }
            }
        }
        
        function updateBursts() { const now = Date.now(); for (let i = worldState.activeBursts.length - 1; i >= 0; i--) { const burst = worldState.activeBursts[i]; if (now >= burst.nextShotTime) { if ((burst.owner === 'player' && (player.isDead || isPlayerInGarage))) { worldState.activeBursts.splice(i, 1); continue; } playUrlSound("shoot", burst.owner); const spawnDist = burst.ownerWidth / 2; worldState.bullets.push({ owner: burst.owner, x: burst.x + Math.cos(burst.angle) * spawnDist, y: burst.y + Math.sin(burst.angle) * spawnDist, dx: Math.cos(burst.angle) * burst.bulletSpeed, dy: Math.sin(burst.angle) * burst.bulletSpeed, radius: burst.owner === 'player' ? 5 : 6, damage: burst.bulletDamage }); burst.shotsFired++; burst.nextShotTime = now + burst.delay; if (burst.shotsFired >= burst.totalShots) { worldState.activeBursts.splice(i, 1); } } } }
        
        function updateBullets() {
            for (let i = worldState.bullets.length - 1; i >= 0; i--) {
                const b = worldState.bullets[i];
                if (!b) continue;
                b.x += b.dx;
                b.y += b.dy;
                if (b.x < camera.x - 100 || b.x > camera.x + camera.width + 100 || b.y < camera.y - 100 || b.y > camera.y + camera.height + 100) {
                    worldState.bullets.splice(i, 1);
                    continue;
                }
                let bulletDestroyed = false;
                const nearbyObjects = spatialGrid.getNearby(b.x, b.y);
                if (b.owner === 'player') {
                    const nearbyEnemies = nearbyObjects.filter(o => o.type !== undefined && o !== player);
                    for (const e of nearbyEnemies) {
                        if (Math.hypot(b.x - (e.x + e.width / 2), b.y - (e.y + e.height / 2)) < (e.width / 2)) {
                            worldState.bullets.splice(i, 1);
                            bulletDestroyed = true;
                            break;
                        }
                    }
                }
                if (bulletDestroyed) continue;
                const nearbyWorldObjects = nearbyObjects.filter(o => o.type !== undefined && o !== player);
                for (const obj of nearbyWorldObjects) {
                    const objWidth = obj.size || obj.width;
                    const objHeight = obj.size || obj.height;
                    if (b.x > obj.x && b.x < obj.x + objWidth && b.y > obj.y && b.y < obj.y + objHeight) {
                        worldState.bullets.splice(i, 1);
                        bulletDestroyed = true;
                        break;
                    }
                }
            }
        }
        
        function updateParticles() { for (let i = worldState.particles.length - 1; i >= 0; i--) { const p = worldState.particles[i]; p.x += p.dx; p.y += p.dy; p.life--; if (p.life <= 0) { worldState.particles.splice(i, 1); } } }


        // --- CORE LOOP ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            camera.width = canvas.width / camera.zoom;
            camera.height = canvas.height / camera.zoom;
        }

        function gameLoop(timestamp) {
            if (!lastTime) { lastTime = timestamp; }
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // --- UPDATE LOGIC ---
            // Fake user input to make the player constantly move
            keys.w = true;

            // Fire a bullet occasionally for testing
            if(Math.random() < 0.2) {
                worldState.bullets.push({ owner: 'player', x: player.x, y: player.y, dx: 10, dy: Math.random() - 0.5 });
            }

            // Call all logic functions now
            updatePlayer(deltaTime);
            updateEnemies();
            updateBursts();
            updateBullets();
            updateParticles();

            // --- DRAWING & CONSOLE ---
            draw();
            consoleDiv.textContent = `dT: ${deltaTime.toFixed(2)}ms`;
            requestAnimationFrame(gameLoop);
        }
        // --- INITIALIZATION ---
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>